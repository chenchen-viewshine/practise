<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0051)https://blog.codingnow.com/2012/07/c_coroutine.html -->
<html xmlns="http://www.w3.org/1999/xhtml" id="sixapart-standard"><head><meta http-equiv="Content-Type" content="text/html; charset=GBK">
   
   <meta name="generator" content="Movable Type 3.2b5">

   <link rel="stylesheet" href="./云风的 BLOG_ C 的 coroutine 库_files/styles-site.css" type="text/css">
   <link rel="stylesheet" type="text/css" media="all" href="./云风的 BLOG_ C 的 coroutine 库_files/mtcolorer.css">
   <link rel="alternate" type="application/atom+xml" title="Atom" href="https://blog.codingnow.com/atom.xml">
   <link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="https://blog.codingnow.com/index.xml">

   <title>云风的 BLOG: C 的 coroutine 库</title>

   <link rel="start" href="https://blog.codingnow.com/" title="Home">
   <link rel="prev" href="https://blog.codingnow.com/2012/07/dev_note_23.html" title="开发笔记(23) : 原子字典">
   <link rel="next" href="https://blog.codingnow.com/2012/07/dev_note_24.html" title="开发笔记(24) : Lua State 间的数据共享">

   <!--
<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
         xmlns:trackback="http://madskills.com/public/xml/rss/module/trackback/"
         xmlns:dc="http://purl.org/dc/elements/1.1/">
<rdf:Description
    rdf:about="https://blog.codingnow.com/2012/07/c_coroutine.html"
    trackback:ping="https://blog.codingnow.com/cgi-bin/mt/mt-tb.cgi/733"
    dc:title="C 的 coroutine 库"
    dc:identifier="https://blog.codingnow.com/2012/07/c_coroutine.html"
    dc:subject="语言与设计"
    dc:description="今天实现了一个 C 用的 coroutine 库. 我相信这个东西已经被无数 C 程序员实现过了, 但是通过 google 找了许多, 或是接口不让我满意, 或是过于重量. 在 Windows 下, 我们可以通过 fiber 来实现 coroutine , 在 posix 下, 有更简单的选择就是 setcontext 。 我的需求是这样的：..."
    dc:creator="Cloud"
    dc:date="2012-07-23T21:25:44+08:00" />
</rdf:RDF>
-->


   

   <script async="" src="./云风的 BLOG_ C 的 coroutine 库_files/analytics.js.下载"></script><script type="text/javascript" src="./云风的 BLOG_ C 的 coroutine 库_files/mt-site.js.下载"></script>
</head>
<body class="layout-one-column" onload="individualArchivesOnLoad(commenter_name)">
   <div id="container">
      <div id="container-inner" class="pkg">

         <div id="banner">
            <div id="banner-inner" class="pkg">
               <h1 id="banner-header"><a href="https://blog.codingnow.com/" accesskey="1">云风的 BLOG</a></h1>
               <h2 id="banner-description">思绪来得快去得也快，偶尔会在这里停留</h2>
            </div>
         </div>

         <div id="pagebody">
            <div id="pagebody-inner" class="pkg">
               <div id="alpha">
                  <div id="alpha-inner" class="pkg">

                     <p class="content-nav">
                        <a href="https://blog.codingnow.com/2012/07/dev_note_23.html">&#171; 开发笔记(23) : 原子字典</a> |
                        <a href="https://blog.codingnow.com/">返回首页</a>
                        | <a href="https://blog.codingnow.com/2012/07/dev_note_24.html">开发笔记(24) : Lua State 间的数据共享 &#187;</a>
                     </p>

                     <a id="a000773"></a>
                     <div class="entry" id="entry-773">
                        <h3 class="entry-header">C 的 coroutine 库</h3>
                        <div class="entry-content">
                           <div class="entry-body">
                              <p>今天实现了一个 <a href="https://github.com/cloudwu/coroutine/">C 用的 coroutine 库</a>.</p>

<p>我相信这个东西已经被无数 C 程序员实现过了, 但是通过 google 找了许多, 或是接口不让我满意, 或是过于重量.</p>

<p>在 Windows 下, 我们可以通过 <a href="http://blog.codingnow.com/2005/10/fiber.html">fiber</a> 来实现 coroutine , 在 posix 下, 有更简单的选择就是 <a href="http://en.wikipedia.org/wiki/Setcontext">setcontext</a> 。</p>

<p>我的需求是这样的：</p>

                           </div>
                           <div id="more" class="entry-more">
                              <p>首先我需要一个 asymmetric coroutine 。如果你用过 lua 的 coroutine 就明白我指的是什么。</p>

<p>其次，我不希望使用 coroutine 的人太考虑 stack 大小的问题。就是说，用户在 coroutine 内可以使用的 C stack 大小和主线程一样多。</p>

<p>我需要单个 coroutine 空间占有率不要太高，因为我可能会使用上千个 coroutine ，我不希望每个都占用百万字节的堆栈。</p>

<p>因为，在我的应用场合，coroutine 切换的那一刻，使用的堆栈并不多（它可能调用一些需要大量堆栈的库函数，但那些库函数中并不会发生切换），所以，在切换的时刻做栈拷贝是可以接受的。coroutine 切换并不算频繁，这个切换成本是可控的。</p>

<p>最终，我以我的需求实现了我需要的这个版本。</p>

<p>当然，暂时它不支持 windows 。其实 port 到 windows 平台不算困难，只需要把 setcontext 那组 api 改成 fiber 的即可。</p>

                           </div>
                        </div>
                        <p class="entry-footer">
                           <span class="post-footers">云风 提交于 July 23, 2012 09:25 PM</span> <span class="separator">|</span> <a class="permalink" href="https://blog.codingnow.com/2012/07/c_coroutine.html">固定链接</a>
                        </p>
                     </div>

                     

                                          <div id="comments" class="comments">
                        <div class="comments-content">
                                                      <h3 class="comments-header">Comments</h3>
                           <a id="c047268"></a>
                           <div class="comment" id="comment-47268">
                              <div class="comment-content">
                                 <p>在mainfunc结束前_co_delete了，那结束mainfunc后有个隐含的swapcontext(C-&gt;ctx.uc_link）这个也被释放了，跑一次两次问题不大，多跑几次或者多线程下，肯定出问题。</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  vical  | (44) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-47268">December 28, 2017 06:19 PM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c046842"></a>
                           <div class="comment" id="comment-46842">
                              <div class="comment-content">
                                 <p>局部变量不能用于异步回调赋值。</p>

<p>struct schedule *s;</p>

<p>void<br>
work_done_cb(async_result_t *res, void *user_data)<br>
{<br>
  async_result_t **resp = user_data;<br>
  <br>
  *resp = res;<br>
}</p>

<p>void<br>
task_func(void *arg)<br>
{<br>
  async_result_t *res = NULL;<br>
  <br>
  do_work_async(work_done_cb, &amp;res);<br>
  <br>
  while(!res)<br>
  {<br>
    coroutine_yield(s);<br>
  }<br>
  // BUG: 就算 work_done_cb 被调用了，你的堆栈内容恢复机制也会覆盖掉 work_done_cb  中对 res 的赋值，因此无法执行到这里<br>
  ...<br>
}</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  余松  | (43) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-46842">April  5, 2017 03:51 PM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c046740"></a>
                           <div class="comment" id="comment-46740">
                              <div class="comment-content">
                                 <p> @bughoho  我觉得你对协程的运行原理理解错了。基于协程，只能使用overlap io,本身这个技术是不支持block io.</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                   progmalover  | (42) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-46740">January 19, 2017 12:12 PM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c046695"></a>
                           <div class="comment" id="comment-46695">
                              <div class="comment-content">
                                 <p>膜拜</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  itfanr  | (41) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-46695">December 18, 2016 08:58 PM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c046428"></a>
                           <div class="comment" id="comment-46428">
                              <div class="comment-content">
                                 <p>应该可以直接用 libevent 吧。</p>

<p>Python 里面 gevent 实现协程，底层就是用的这个库</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  Anonymous  | (40) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-46428">April 29, 2016 07:28 PM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c046036"></a>
                           <div class="comment" id="comment-46036">
                              <div class="comment-content">
                                 <p>请问一下这种情况:<br>
在一个协程中触发了异常后，在异常处理块中（这时并未NtContinue继续执行）yield到另外一个协程中会有问题吗？</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  bughoho  | (39) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-46036">September 19, 2015 10:42 PM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c045656"></a>
                           <div class="comment" id="comment-45656">
                              <div class="comment-content">
                                 <p>我认为你的这个实现是错误的。<br>
因为栈数据是不能拷贝到别的地址的，这样做将导致指向此栈上变量的指针失效。<br>
如 伪码<br>
char buf[64];<br>
read_from_net(socket, buf);</p>

<p>在此函数里导致协程挂起，等待io完成并重新调度回来，而buf的地址在原来malloc分配的块，这个块已经被另作他用，这个a是野的。</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  codechurch  | (38) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-45656">March  3, 2015 01:23 PM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c045649"></a>
                           <div class="comment" id="comment-45649">
                              <div class="comment-content">
                                 <p>不好意思，看到id重复利用的地方了~</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  xphh  | (37) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-45649">February 25, 2015 09:41 PM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c045648"></a>
                           <div class="comment" id="comment-45648">
                              <div class="comment-content">
                                 <p>学习了！</p>

<p>不过有个地方，协程id的管理实在有点简单，id是无法回收的。所以这样理解不知是否有误：频繁创建/销毁协程，会有内存泄露。</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  xphh  | (36) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-45648">February 25, 2015 09:26 PM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c045519"></a>
                           <div class="comment" id="comment-45519">
                              <div class="comment-content">
                                 <p>我是结合epoll，在任务激活时获取栈，一个requist结束时归还栈。</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  Anonymous  | (35) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-45519">December 24, 2014 11:21 AM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c045518"></a>
                           <div class="comment" id="comment-45518">
                              <div class="comment-content">
                                 <p>我也做了一个，跟你的需求差不多。</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  Anonymous  | (34) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-45518">December 24, 2014 11:17 AM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c045517"></a>
                           <div class="comment" id="comment-45517">
                              <div class="comment-content">
                                 <p>我也做了一个，跟你的需求差不多。</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  Anonymous  | (33) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-45517">December 24, 2014 11:17 AM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c045516"></a>
                           <div class="comment" id="comment-45516">
                              <div class="comment-content">
                                 <p>我也做了一个，跟你的需求差不多。</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  Anonymous  | (32) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-45516">December 24, 2014 11:17 AM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c045268"></a>
                           <div class="comment" id="comment-45268">
                              <div class="comment-content">
                                 <p>真是功力深厚啊</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  啥都不懂就老了  | (31) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-45268">August  6, 2014 10:18 PM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c044914"></a>
                           <div class="comment" id="comment-44914">
                              <div class="comment-content">
                                 <p>这应该是此需求下最合理的实现了</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  alionkun  | (30) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-44914">March 26, 2014 03:38 PM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c044776"></a>
                           <div class="comment" id="comment-44776">
                              <div class="comment-content">
                                 <p>top - &amp;dummy这个是什么意思，没太明白，求@cloud 解释下</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  浪客  | (29) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-44776">February 28, 2014 01:23 PM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c044691"></a>
                           <div class="comment" id="comment-44691">
                              <div class="comment-content">
                                 <p>本来很好奇切换上下文时是怎样把函数栈帧保存下来的，后来看了main函数第一句分配了schedule结构体，而stack就在结构体第一个变量就明白了。确实巧妙！</p>

<p>不过不需要每个协程维护一个上下文，因为每个协程已经有自己的stack了。由于程序没有并发，只要保留两个context之间切换即可，一个用于当前，一个用于上一个。</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  Leo  | (28) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-44691">January 26, 2014 05:44 PM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c044328"></a>
                           <div class="comment" id="comment-44328">
                              <div class="comment-content">
                                 <p>貌似没啥人去实现WIN32版本的，就看了一下然后改造成WIN fiber的版本，按说只需要替换接口，不过WINDOWS的CreateFiber(Ex)并不能直接读取/替换堆栈是吧？一时间感觉无从下手。</p>

<p>今天再折腾了一下，做了个测试程序，好像用CreteFiberEx的话，直接把commit设置比较小（随便弄了个32bytes），然后reserved弄1M，相当于就会自己根据大小去调整尺寸了（用任务管理器看提交大小或者工作集，弄一个1M的数组，可以看到内存会自己调整，程序并不会出现崩溃）不知道是不是和操作系统有关系。</p>

<p>改造完成能跑上面的main例子，把源程序堆栈复制的部分都屏蔽了（因为每一个堆栈都会“自动”按需扩容……），就不知道是不是支持大量并发，暂时没大量的例子。</p>

<p>PS：另外做了一个commit &gt; reserved的测试也正常运行，看来微软保护算是做得挺完整了……</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  <a href="http://littlewaterxp.blog.163.com/" rel="nofollow">littlewater</a>  | (27) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-44328">October 27, 2013 10:19 AM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c044036"></a>
                           <div class="comment" id="comment-44036">
                              <div class="comment-content">
                                 <p>@plain</p>

<p>不可以</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  Cloud  | (26) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-44036">June 18, 2013 12:55 PM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c044035"></a>
                           <div class="comment" id="comment-44035">
                              <div class="comment-content">
                                 <p>一个疑问，可以在不同的线程下使用coroutine_resume吗？</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  plain  | (25) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-44035">June 18, 2013 10:24 AM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c043918"></a>
                           <div class="comment" id="comment-43918">
                              <div class="comment-content">
                                 <p>这是不是跟golang里面的gorouting一样一样的？</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  <a href="http://rongmayisheng.com/" rel="nofollow">weager</a>  | (24) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-43918">May  3, 2013 09:26 PM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c043350"></a>
                           <div class="comment" id="comment-43350">
                              <div class="comment-content">
                                 <p>c  coroutine <br>
中使用了 swapcontext<br>
这个在gdb coredump的时候<br>
貌似无法查看到调用coroutine的栈<br>
只能看到切换上下文后的栈。<br>
我查看了好些资料，这个貌似无法解决。  云风大哥给个方案吧</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  fastfading  | (23) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-43350">November  1, 2012 10:26 AM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c043303"></a>
                           <div class="comment" id="comment-43303">
                              <div class="comment-content">
                                 <p>@Cloud</p>

<p>hi, 接触协程不久, 刚试了一下你的coroutine库, 我想在各个coroutine之间共享sys/queue.h里的队列作消息通信, 但是运行时显示断错误.可否指点一二.</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  Alex  | (22) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-43303">October 24, 2012 08:41 AM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c043070"></a>
                           <div class="comment" id="comment-43070">
                              <div class="comment-content">
                                 <p>@dannoy @Cloud<br>
是我理解错了。<br>
本以为栈是使用的malloc分配的空间。<br>
原来是每次拷贝，还是用的主栈的空间。</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  Genius  | (21) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-43070">August 21, 2012 10:09 AM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c043068"></a>
                           <div class="comment" id="comment-43068">
                              <div class="comment-content">
                                 <p>@Cloud<br>
谢谢回复。<br>
是我自己的失误，相当然的把makecontext里的函数看成了C-&gt;func,其实是mainfunc</p>

<p>@Genius <br>
运行时的stack是S-&gt;stack,每次在运行前恢复了先前保存的栈</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  dannoy  | (20) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-43068">August 20, 2012 11:10 AM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c043057"></a>
                           <div class="comment" id="comment-43057">
                              <div class="comment-content">
                                 <p>@dannoy</p>

<p>可以 man makecontext</p>

<p> On  architectures  where int and pointer types are the same size (e.g., x86-32, where both types are 32 bits), you may  be able to get away with passing pointers as arguments to makecontext() following argc.  However, doing  this  is  not   guaranteed to be portable, is undefined according to the standards, and won't work on architectures where pointers are    larger than ints.  Nevertheless, starting with version 2.8, glibc makes some changes to makecontext(3), to permit this on some 64-bit architectures (e.g., x86-64).<br>
</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  Cloud  | (19) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-43057">August 17, 2012 06:16 PM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c043055"></a>
                           <div class="comment" id="comment-43055">
                              <div class="comment-content">
                                 <p>@Cloud</p>

<p>有一个疑问请教一下，line 135的代码：<br>
makecontext(&amp;C-&gt;ctx, (void (*)(void)) mainfunc, 2, (uint32_t)ptr, (uint32_t)(ptr&gt;&gt;32));<br>
1、为什么这样传的S指针过去？是因为运行的系统是64bit吗？<br>
2、为什么没有看到传参数ud呢，但是运行又是正确的，能讲一下原理吗？我把代码这行代码改为以下代码也可正常运行：<br>
uintptr_t ptr2 = (uintptr_t)C-&gt;ud;<br>
makecontext(&amp;C-&gt;ctx, (void (*)(void)) mainfunc, 4, ptr, ptr&gt;&gt;32,ptr2, ptr2&gt;&gt;32);<br>
所以我猜测原来的代码也是有某种机制来传第二个参数的，请指教。<br>
谢谢！</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  dannoy  | (18) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-43055">August 17, 2012 04:41 PM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c043017"></a>
                           <div class="comment" id="comment-43017">
                              <div class="comment-content">
                                 <p>总觉得那个_save_stack函数会有问题：<br>
具体在第153行，if条件语句<br>
1.从调用coroutine_yield到_save_stack函数过程中使用的栈都是C-&gt;stack吧，也就是说free函数翻译时，这个空间正在被使用中！<br>
2.仅仅直接改C-&gt;stack指针能行么？esp ebp等寄存器都没变呢，栈跟本没改。这样在后面使用的其实仍然是之前分配的空间，swapcontext保存下来的上下文也是。潜在的BUG !</p>

<p>请楼主测试函数的该分支条件</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  <a href="http://note.youdao.com/share/?id=ea6867d2a299a1a27774e32ca9182b3d&amp;type=note" rel="nofollow">Genius</a>  | (17) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-43017">August  5, 2012 04:01 PM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c042978"></a>
                           <div class="comment" id="comment-42978">
                              <div class="comment-content">
                                 <p>好把，我只膜拜下。</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  <a href="http://www.gushici5.com/" rel="nofollow">古诗词网</a>  | (16) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-42978">July 27, 2012 12:22 AM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c042976"></a>
                           <div class="comment" id="comment-42976">
                              <div class="comment-content">
                                 <p>不懂，但膜拜</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  枫叶  | (15) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-42976">July 26, 2012 11:21 AM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c042975"></a>
                           <div class="comment" id="comment-42975">
                              <div class="comment-content">
                                 <p>140元的还是DDR3 1600频率的，1333的频率更加便宜呢。</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  David Xu  | (14) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-42975">July 26, 2012 10:31 AM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c042974"></a>
                           <div class="comment" id="comment-42974">
                              <div class="comment-content">
                                 <p>1万个co-routine, 平均每个64K堆栈（ 已经是很大的堆栈了），才640兆。现在4G的PC ddr3内存是140元左右， 服务器内存可能贵一点，但是贵不太多。<br>
:D</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  David Xu  | (13) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-42974">July 26, 2012 10:29 AM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c042973"></a>
                           <div class="comment" id="comment-42973">
                              <div class="comment-content">
                                 <p>@David Xu</p>

<p>的确, 在 64bit 系统上, coroutine 占用的堆栈内存是不会有太多问题. 应该是我多虑了.</p>

<p>我现在有几百个实体, 在 10 条左右的 os thread 上调度. (调度单位是实体内的一个函数调用) 每个实体里需要上十个 coroutine.</p>

<p>粗略算起来是万级的 coroutine 左右.</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  Cloud  | (12) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-42973">July 25, 2012 08:37 PM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c042970"></a>
                           <div class="comment" id="comment-42970">
                              <div class="comment-content">
                                 <p>在64位系统里，堆栈申请的大或者co-routine比较多，导致总体堆栈内存空间申请的大，不一定会有很大的影响。为什么呢？因为你申请到的是虚拟内存，只要你实际不去触碰(touch)那些内存，例如mmap申请堆栈后又来一个没必要的memset()成0,实际内存需求将按函数执行时的需求来，所以总体上实际物理内存需求可能也不大，libc里嵌套最深的函数，也许实际不超过几K堆栈需求。</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  David Xu  | (11) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-42970">July 25, 2012 05:26 PM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c042969"></a>
                           <div class="comment" id="comment-42969">
                              <div class="comment-content">
                                 <p>为了测试堆栈是否溢出，如你给co-routine的堆栈太小了，建议的方式是内存通过mmap()申请，然后在申请到的这块内存的开头，你用mprotect把他砍下来，成为红区，不能读写。这样，当堆栈从高地址往低地址涨的时候，如果涨太多就碰到红区，这段内存不可读写，程序马上就segment fault。这有利于检查程序的问题。我在线程库libthr上就是这样做的。<br>
例如假设红区大小是一个guard page (4096字节 ):<br>
那总共要申请的就是<br>
guard_page + stack_size.</p>

<p>p = (char *)mmap(guard_page+stack_size).<br>
然后<br>
mprotect(p, 4096, PROT_NONE);<br>
return (p+4096);<br>
</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  David Xu  | (10) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-42969">July 25, 2012 04:59 PM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c042968"></a>
                           <div class="comment" id="comment-42968">
                              <div class="comment-content">
                                 <p>@cloud</p>

<p>不知道我这样对不对：如果想准备一个新的co-routine,可以用makecontext（）先建立一个初始化上下文。它的原型是这样的： void<br>
     makecontext(ucontext_t *ucp, void (*func)(void), int argc, ...);</p>

<p>也就是你可以传入一个新的入口函数地址，以及argc个参数给这个入口函数。这个ucp所指向的ucontext_t是你用getcontext（）获得的，没什么理由，就是为了得到一个合理的寄存器状态数据，而不是随机的垃圾。然后，你用这个ucontext里的uc_stack设置你想给这个co-routine的新的堆栈：<br>
例如：<br>
ucp-&gt;uc_stack.ss_size = 4096;<br>
ucp-&gt;uc_stack.ss_sp = my_stack_memory。</p>

<p>然后调用makecontext.<br>
makecontext将会为你设置好机器相关的堆栈指针：<br>
它可能是ss_size+ss_sp（在x86上），然后再往低地址填充一些东西。<br>
总之，它给你一个合理的初始化上下文，入口指向你给出的函数。</p>

<p>所以，你创建一个co-routine，它的堆栈是可以预先固定大小的。</p>

<p>至于你说的拷贝，我就不了解了。</p>

<p>在FreeBSD上你可以参考libc里的makecontext的实现：<br>
/usr/src/lib/libc/i386/gen/makecontext.c</p>

<p>然后继续使用setjmp+longjmp.</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  David Xu  | (9) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-42968">July 25, 2012 04:50 PM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c042961"></a>
                           <div class="comment" id="comment-42961">
                              <div class="comment-content">
                                 <p>@David Xu</p>

<p>我先实现了一个 longjmp 版的. 但是切换堆栈会比较繁琐.</p>

<p>其实开销是可以容忍的. copy stack 的开销也很大. 尽量减少开销次数了.</p>

<p>更需要的是实现大量的 coroutine, 但是活动状态的并不多. 所以不希望每个 coroutine 都占用太多内存.</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  Cloud  | (8) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-42961">July 24, 2012 05:55 PM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c042960"></a>
                           <div class="comment" id="comment-42960">
                              <div class="comment-content">
                                 <p>希望我没理解错，我只看了几分钟。我觉的你是要轻量级东西。但是目前我知道setcontext和getcontext都是系统调用。开销比较大。建议你还是用setjmp+longjmp.<br>
setcontext和getcontext更多的是偏向支持实时抢占方式的，所以上下文保存都是通过内核调用。目前编译器生成的浮点指令都以函数调用为边界，浮点处理器状态并不跨函数调用而存在，所以你这种非实时抢先的co-routine，setjmp+longjmp就可以了。lua用到浮点单元，但是setjmp已经做了必要的状态字保存，问题不大。</p>

<p>另，好久不见，不知道现在怎样了。<br>
</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  David Xu  | (7) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-42960">July 24, 2012 05:41 PM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c042958"></a>
                           <div class="comment" id="comment-42958">
                              <div class="comment-content">
                                 <p>不知道楼主是否知道gnupth项目，我们的项目就在使用它，gnupth除了实现了coroutine，还有许多其他的好处，比如访问到阻塞调用，可以直接切换到另一个coroutine执行。</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  deverchang  | (6) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-42958">July 24, 2012 01:45 PM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c042957"></a>
                           <div class="comment" id="comment-42957">
                              <div class="comment-content">
                                 <p>这样的方式, 在设置全局变量为协程的堆栈变量(引用地址), 协程切换后再引用全局变量时会有问题. 通常的假设是协程未结束, 则堆栈地址有效.</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  changsheng  | (5) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-42957">July 24, 2012 12:29 PM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c042955"></a>
                           <div class="comment" id="comment-42955">
                              <div class="comment-content">
                                 <p>虽然coroutine有时很方便,但我觉得这种模式不是必需的,总有其它框架模式可以替代,同样能够实现需求.</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  <a href="http://tieba.baidu.com/f?kw=dwing" rel="nofollow">dwing</a>  | (4) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-42955">July 24, 2012 09:50 AM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c042954"></a>
                           <div class="comment" id="comment-42954">
                              <div class="comment-content">
                                 <p>膜拜</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  jameslz  | (3) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-42954">July 24, 2012 05:54 AM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c042953"></a>
                           <div class="comment" id="comment-42953">
                              <div class="comment-content">
                                 <p>沙发</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  zr  | (2) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-42953">July 24, 2012 12:40 AM</a> 
                              </p>
                           </div>
                                                      
                           <a id="c042952"></a>
                           <div class="comment" id="comment-42952">
                              <div class="comment-content">
                                 <p>沙发</p>
                              </div>
                              <p class="comment-footer">
                                 Posted by:
                                  zr  | (1) 
                                 <a href="https://blog.codingnow.com/2012/07/c_coroutine.html#comment-42952">July 24, 2012 12:40 AM</a> 
                              </p>
                           </div>
                           
                        </div>

                         
                        <form method="post" action="https://blog.codingnow.com/cgi-bin/mt/mt-comments.cgi" name="comments_form" onsubmit="if (this.bakecookie.checked) rememberMe(this)">
                           <input type="hidden" name="static" value="1">
                           <input type="hidden" name="entry_id" value="773">
                           
                           <div class="comments-open" id="comments-open">
                              <h2 class="comments-open-header">Post a comment</h2>
                             <center><b>非这个主题相关的留言请到：<a href="http://www.codingnow.com/2004/board">留言本</a></b></center>
                              
                              <div class="comments-open-content">
                                 <script type="text/javascript">
                                 <!--
                                // writeTypeKeyGreeting(commenter_name, 773);
                                 //-->
                                 </script>
                              
                                 

                                 <div id="comments-open-data">
                                    <div id="name-email">
                                       <p>
                                          <label for="comment-author">名字：</label>
                                          <input id="comment-author" name="author" size="30">
                                       </p>
                                       <p>
                                          <label for="comment-email">Email 地址：</label>
                                          <input id="comment-email" name="email" size="30">
                                       </p>
                                    <p>
                                      <label for="comment-fcode"><b>为了验证您是人类</b>，请将六加一的结果（阿拉伯数字七）填写在下面：</label>
                                       <input id="comment-fcode" name="fcode" size="30">
                                    </p>
                                    </div>
                                    <p>
                                       <label for="comment-url">URL:</label>
                                       <input id="comment-url" name="url" size="30">
                                    </p>
                                    <p>
                                       <label for="comment-bake-cookie"><input type="checkbox" id="comment-bake-cookie" name="bakecookie" onclick="if (!this.checked) forgetMe(document.comments_form)" value="1">
                                          记住我的信息？</label>
                                    </p>
                                 </div>

                                 <p id="comments-open-text">
                                    <label for="comment-text">留言：<br>（不欢迎在留言中粘贴程序代码）</label>
                                    <textarea id="comment-text" name="text" rows="10" cols="30"></textarea>
                                 </p>
                                 <div id="comments-open-footer" class="comments-open-footer">
                                    <input type="submit" accesskey="s" name="post" id="comment-post" value="提交">
                                 </div>
                              </div>
                           </div>
                        </form>
                        
                     </div>
                     
                  </div>
               </div>
            </div>
         </div>
      </div>
   </div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-1194145-1', 'auto');
  ga('send', 'pageview');
</script>


</body></html>