2002年初，笔者着手写一个IC卡预付费电表的工作程序，该电表使用Philips公司的8位51扩展型单片机87LPC764，要求实现很多功能，包括熄显示、负荷计算与控制、指示闪烁以及电表各种参数的查询等，总之，要使用时间的单元很多。笔者当时使用ASM51完成了这个程序的编写，完成后的程序量是2KB多一点。后来，由于种种原因，这个程序并没有真正使用，只是作了一些改动之后用在一个老化设备上进行计时与负荷计算。约一年后，笔者又重新改写了这些代码。

1 系统的改进

　　可以说，这个用ASM51实现的代码是没有什么组织性可言的，要什么功能就加入什么功能，弄得程序的结构非常松散，其实这也是导致笔者最终决定重新改写这些代码的原因。

　　大家知道，87LPC764有4KB的Flash ROM，而笔者的程序量只有2KB多点，因而第一个想法是改用C语言作为主要的开发语言，应该不至于导致代码空间不够用。其次，考虑到需要定时功能的模块(或称任务，以下统称任务)较多，有必要对这些任务进行有序的管理。笔者考虑使用时间片轮询方式，即给每个要求时间管理的任务以一个时间间隔，时间间隔一到，即运行其代码，达到合理使用系统定时器资源的目的。就51系统而言，一般至少一个定时器可用来进行时间片的轮询。基于以上的想法，构造了下述数据类型。

typedef unsigned char uInt8
typedef struct 
{
	void (*proc)(void); //处理程序
	uInt8 ms_count; //时间片大小
} _op_;
数据结构定义好之后，接着就是实现代码，包括三部分，即初始化数据、时间片的刷新与时间到执行。
初始化数据。
#define proc_cnt 0x08 //定义过程或任务数量
//任务栈初始化
code _op_ Op[proc_cnt]={{ic_check，10}，{disp_loop，100}，\
{
	calc_power，150}，{set_led，2}，…\
};
//设置时间片初始值
data uInt8 time_val[proc_cnt]={10，100，150，2，…};
时间片刷新。
void time_int1(void) interrupt 3
{
	uInt8 cnt;
	Time_Counter:=Time_Unit;
	for(cnt=0;cnt<proc_cnt;cnt++)
	{
		time_val[cnt]--;
	}
}
任务的执行。
void main(void)
{
	uInt8 cnt;
	init(); //程序初始化
	interrupt_on(); //打开中断
	do
	{
		for(cnt=0;cnt<proc_cnt;cnt++)
		{
			if(!time_val[cnt])
			{
				time_val[cnt]=Op[cnt].ms_count;
				Op[cnt].proc();
			}
		}
	}while(1);
}

　　在上面的结构定义中，proc是不能带参数的，各任务之间的通信可以定义一个参数内存块，通过一种机制进行数据信息交互，如定义一个全局变量。对于小容量单片机系统而言，需要这样做的任务并不多，总任务量也不会太多，因而这种协调并不太难处理。

　　也许大家都有这样的认识，即一个实时系统中，差不多所有的具体任务都是有时间属性的，即使是不需要定时的过程或任务，也不见得要时时进行查询与刷新。如IC卡介质检测，保证每秒一次就足够了。因而，这些任务也可以列入到这个结构中来。

　　在以上的程序代码中，考虑到单片机系统的RAM限制，不能像一些实时OS那样将任务栈建立在RAM中。笔者将任务栈建立在代码空间，因而不能在程序运行时动态地加入任务，因此要求在程序编译时，任务栈已经确定。同时，定义一组计数值旗标time_val，记录程序运行时的时间量，并在一个定时器中断中对其进行刷新。改变时间片刷新中断过程语句Time_Counter:=Time_Unit;中的Time_Unit，可以改变系统时间片的刷新粒度，一般这个值由系统的最小时间度量值确定。

　　同时，由任务的执行流程可知，此种系统构造并没有改变其前/后台系统的性质，只是对后台逻辑操作序列进行了有效管理。同时，如果将任务执行流程进行一些更改，并保证时间片小的任务前置，如下述程序。
do{
	for(cnt=0;cnt<proc_cnt;cnt++)
	{
		if(!time_val[cnt])
		{
			time_val[cnt]=Op[cnt].ms_count;
			Op[cnt].proc();
			break; //执行完成后，重新进行优先调度
		}
	}
}while(1);

　　则系统变为一个以执行频率为优先级的任务调度系统。当然，设置此种方式得非常小心，并要注意时间片的分配，如果时间片过小，则可能导致执行频率较低的任务难以被执行；而如果存在两个同样的时间片，则更加危险，可能导致第二个具有相同时间片的任务不被执行，因而，时间片的分配要合理，并保证其唯一性。

2 性能分析与任务拆分

　　以上两种任务管理方式，前一种按任务栈的顺序与时间片的大小依次进行调度，暂且称其为流水作业调度；而后一种，且称其为频率优先调度。两种方式各有优缺点。流水作业调度的各任务具有等同优先级，时间片一到即会被按序调用，时间片大小的次序与唯一性不作要求；缺点是可能导致时间片小的，即要求执行得较快的任务等待过长的时间。频率优先调度的各任务按其时间片的大小，即执行频率划分优先级，时间片小的任务，其执行频率高，总是具有较高的优先权，但时间片的分配得协调，否则可能会导致执行频率低的任务长时间等待。

　　要特别注意的是，两种方式都有可能导致一些任务长时间等待，时间片所设定的时间也因此不能作为精确时间的依据，根据系统的要求或需要，甚至要在任务执行过程中进行某些保护工作，如中断屏蔽等，因而在进行任务规划时要注意。如果一个任务较繁琐或可能要等待很长时间，则应当考虑任务的拆分，把一个较大的任务细化为较小的任务，把一个费时长的任务划分为多个费时小的任务，协同完成其功能。如在等待时间长的情况下，可附加一个定时任务，定时任务到则发送一个消息旗标，主过程没有检测到消息旗标就马上返回，否则继续执行。下面是示例代码，假定该任务将等待很长时间，现将其拆分为两个任务proc1与proc2协同完成原来的工作，proc1每100个时间单位执行一次，而proc2每200个时间单位执行一次。

//定义两个任务，并将其加入到任务栈中。
code _op_ Op[proc_cnt]={…，{proc1，100}，{proc2，200}};
data int time1_Seg; //定义一个全局旗标
//任务实现
void proc1(void)
{
	if (time1_Seg)
		exit;
	else
		time1_Seg=const_Time1; //如果时间到了，则恢复初值并
	//接着执行下列代码。
	… //任务实际执行代码
} 
void proc2(void)
{ 
	if(time1_Seg) 
		time1_Seg--; 
}

　　由上例可以看出，任务拆分后，几乎不占过多的CPU时间，使得任务的等待时间大减，让CPU有足够的时间进行任务管理与调度。同时也让程序的结构性与可读性大为加强。